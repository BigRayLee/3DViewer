#include "MeshSimplifier.h"

#include "mesh_simplify/meshoptimizer_mod.h"
#include "mesh_simplify/simplify_mod_tex.h"

/* Threads number */
const unsigned short threadNum = 8;
pthread_mutex_t block_index_mutex;
unsigned idx_to_do;

size_t RemapIndexBufferSkipDegenerate(uint32_t *indices, size_t index_count, const uint32_t *remap)
{
    size_t new_index_count = 0;

    for (size_t i = 0; i < index_count; i += 3)
    {
        uint32_t i0 = remap[indices[i + 0]];
        uint32_t i1 = remap[indices[i + 1]];
        uint32_t i2 = remap[indices[i + 2]];

        if (i0 != i1 && i0 != i2 && i1 != i2)
        {
            indices[new_index_count + 0] = i0;
            indices[new_index_count + 1] = i1;
            indices[new_index_count + 2] = i2;
            new_index_count += 3;
        }
    }

    return new_index_count;
}

size_t CollapseSimplifyMesh(uint32_t *out_indices, uint32_t *simplification_remap, const uint32_t *indices, size_t index_count,
                            const void *vertices, size_t vertex_count, int vertex_stride, size_t target_index_count, float targetError, float block_extend, float block_bottom[3])
{
    return meshopt_simplify_mod((unsigned int *)out_indices, (unsigned int *)simplification_remap,
                                (const unsigned int *)indices, index_count, (const float *)vertices, vertex_count, vertex_stride, target_index_count,
                                targetError, NULL, block_extend, block_bottom);
}

size_t CollapseSimplifyMeshTex(uint32_t *out_indices, uint32_t *out_indicesUV, uint32_t *simplification_remap, uint32_t *simplification_remap_uv,
                               const uint32_t *indices, size_t index_count, const uint32_t *indicesUV, size_t index_uv_count,
                               const void *vertices, size_t vertex_count, const void *uvs, size_t uv_count, unsigned vertex_stride, unsigned uv_stride,
                               size_t target_index_count, float targetError, float block_extend, float block_bottom[3])
{
    return meshopt_simplify_mod_texDebug((unsigned int *)out_indices, (unsigned int *)out_indicesUV, (unsigned int *)simplification_remap,
                                         (unsigned int *)simplification_remap_uv, (const unsigned int *)indices, index_count,
                                         (const unsigned int *)indicesUV, index_uv_count, (const float *)vertices, vertex_count, (const float *)uvs,
                                         uv_count, vertex_stride, uv_stride, target_index_count, targetError, NULL, block_extend, block_bottom);
}

unsigned LoadBlockData(HLOD *hlod, Boxcoord& bottom, int curLevel, int width, uint64_t *cubeList, Mesh *destination, bool isGetData){
    Boxcoord temp;
    size_t indexOffset = 0;
    size_t vertexOffset = 0;
    size_t uvIndexOffset = 0;
    size_t uvOffset = 0;

    unsigned cubeCount = 0;
    short nx = bottom.x;
    short ny = bottom.y;
    short nz = bottom.z;

    for (int dx = 0; dx < width; dx++)
    {
        temp.x = nx + dx;
        for (int dy = 0; dy < width; dy++)
        {
            temp.y = ny + dy;
            for (int dz = 0; dz < width; dz++)
            {
                temp.z = nz + dz;

                Boxcoord result;
                if(!ConvertBlockCoordinates(temp, result, SC_BLOCK_SIZE, hlod->lods[curLevel]->gridSize))
                    continue;
                
                uint64_t ijk = (uint64_t)(result.x) | ((uint64_t)(result.y) << 16) | ((uint64_t)(result.z) << 32);
                
                if (hlod->lods[curLevel]->cubeTable.count(ijk) == 0)
                    continue;

                int indexCount = hlod->lods[curLevel]->cubeTable[ijk].GetIndexCount();
                int vertexCount = hlod->lods[curLevel]->cubeTable[ijk].GetVertexCount();

                int uvIndexCount = 0;
                int uvCount = 0;

                if(modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture){
                    uvIndexCount = hlod->lods[curLevel]->cubeTable[ijk].GetTextureIndexCount();
                    uvCount = hlod->lods[curLevel]->cubeTable[ijk].GetTextureParentCount();
                }

                if (isGetData){
                    cubeList[cubeCount] = ijk;

                    size_t cubeVertexOffset = hlod->lods[curLevel]->cubeTable[ijk].vertexOffset;
                    size_t cubeIdxOffset = hlod->lods[curLevel]->cubeTable[ijk].idxOffset;

                    uint32_t *targetIndices = destination->indices + indexOffset;
                    memcpy(targetIndices, (unsigned char *)&(hlod->data.positions[cubeIdxOffset]), indexCount * sizeof(uint32_t));

                    for (size_t i = 0; i < indexCount; ++i){
                        targetIndices[i] = targetIndices[i] + vertexOffset;
                    }
                    
                    /* position */
                    void *targetPosition = (unsigned char *)destination->positions + vertexOffset * VERTEX_STRIDE;
                    memcpy(targetPosition, (unsigned char *)&hlod->data.positions[cubeVertexOffset], vertexCount * VERTEX_STRIDE);

                    /* normal */
                    void *targetNormal = (unsigned char *)destination->normals + vertexOffset * VERTEX_STRIDE;
                    memcpy(targetNormal, (unsigned char *)&hlod->data.normals[cubeVertexOffset], vertexCount * VERTEX_STRIDE);

                    /* color */
                    if(modelAttriSatus.hasColor){
                        void *targetColor = (unsigned char *)destination->colors + vertexOffset * COLOR_STRIDE;
                        memcpy(targetColor, (unsigned char *)&hlod->data.colors[cubeVertexOffset], vertexCount * COLOR_STRIDE);
                    }
                    
                    if(modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture){
                        // TODO: offset
                        uint32_t *targetUVIndices = destination->indicesUV + uvIndexOffset;
                        memcpy(targetUVIndices, (unsigned char *)&(hlod->data.indicesUV[cubeIdxOffset]), uvIndexCount * sizeof(uint32_t));

                        for (size_t i = 0; i < uvIndexCount; ++i)
                            targetUVIndices[i] = targetUVIndices[i] + uvOffset;

                        // TODO: offset
                        void *targetUV = (unsigned char *)destination->uvs + uvOffset * 2 * sizeof(float);
                        memcpy(targetUV, (unsigned char *)&(hlod->data.uvs[cubeVertexOffset]), uvCount * 2 * sizeof(float));
                    }
                }

                cubeCount++;
                
                indexOffset += indexCount;
                vertexOffset += vertexCount;
                
                if(modelAttriSatus.hasSingleTexture|modelAttriSatus.hasMultiTexture){
                    uvIndexOffset += uvIndexCount;
                    uvOffset += uvCount;
                }
            }
        }
    }

    destination->idxCount = indexOffset;
    destination->posCount = vertexOffset;
    
    if(modelAttriSatus.hasSingleTexture|modelAttriSatus.hasMultiTexture){
        destination->idxUVCount = uvIndexOffset;
        destination->uvCount = uvOffset;
    }

    return cubeCount;
}

unsigned ComputeMaxCounts(LOD *mg, Block *blk)
{
    size_t maxIdxCount = 0;
    size_t maxVertexCount = 0;

    size_t maxIdxUVCount = 0;
    size_t maxUVCount = 0;

    unsigned maxBoxCount = 0;

    unsigned short block_counter = 0;

    for (int nx = 0; nx < mg->gridSize + blk->width; nx = nx + blk->width)
    {
        for (int ny = 0; ny < mg->gridSize + blk->width; ny = ny + blk->width)
        {
            for (int nz = 0; nz < mg->gridSize + blk->width; nz = nz + blk->width)
            {
                Boxcoord bottom;
                bottom.x = nx, bottom.y = ny, bottom.z = nz;
                size_t index_count = 0;
                size_t vertex_count = 0;

                size_t index_uv_count = 0;
                size_t uv_count = 0;

                /* Get the data of block */
                Mesh dest;
                size_t box_count = LoadBlockData(mg, bottom, blk->width, NULL, &dest, false, false);

                index_count = dest.idxCount;
                vertex_count = dest.posCount;

                if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
                {
                    index_uv_count = dest.idxUVCount;
                    uv_count = dest.uvCount;
                }

                if (box_count == 0)
                    continue;
                
                blk->list[block_counter] = bottom;
                block_counter++;

                maxBoxCount = box_count > maxBoxCount ? box_count : maxBoxCount;
                maxIdxCount = index_count > maxIdxCount ? index_count : maxIdxCount;
                maxVertexCount = vertex_count > maxVertexCount ? vertex_count : maxVertexCount;

                if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
                {
                    maxIdxUVCount = index_uv_count > maxIdxUVCount ? index_uv_count : maxIdxUVCount;
                    maxUVCount = uv_count > maxUVCount ? uv_count : maxUVCount;
                }
            }
        }
    }
    blk->maxIdxCount = maxIdxCount;
    blk->maxVertexCount = maxVertexCount;
    blk->validBoxCount = block_counter;

    if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
    {
        blk->maxIdxUVCount = maxIdxUVCount;
        blk->maxUVCount = maxUVCount;
    }

    return maxBoxCount;
}

unsigned ComputeMaxCounts(HLOD *hlod, int curLevel, Block* blk){
    size_t maxIdxCount = 0;
    size_t maxVertexCount = 0;

    size_t maxIdxUVCount = 0;
    size_t maxUVCount = 0;

    unsigned maxBoxCount = 0;

    unsigned short block_counter = 0;

    for (int nx = 0; nx < hlod->lods[curLevel]->gridSize + blk->width; nx = nx + blk->width)
    {
        for (int ny = 0; ny < hlod->lods[curLevel]->gridSize + blk->width; ny = ny + blk->width)
        {
            for (int nz = 0; nz < hlod->lods[curLevel]->gridSize + blk->width; nz = nz + blk->width)
            {
                Boxcoord bottom;
                bottom.x = nx, bottom.y = ny, bottom.z = nz;
                size_t index_count = 0;
                size_t vertex_count = 0;

                size_t index_uv_count = 0;
                size_t uv_count = 0;

                /* Get the data of block */
                Mesh dest;
                size_t box_count = LoadBlockData(hlod, bottom, curLevel, blk->width, NULL, &dest, false);

                index_count = dest.idxCount;
                vertex_count = dest.posCount;

                if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
                {
                    index_uv_count = dest.idxUVCount;
                    uv_count = dest.uvCount;
                }

                if (box_count == 0)
                    continue;
                
                blk->list[block_counter] = bottom;
                block_counter++;

                maxBoxCount = box_count > maxBoxCount ? box_count : maxBoxCount;
                maxIdxCount = index_count > maxIdxCount ? index_count : maxIdxCount;
                maxVertexCount = vertex_count > maxVertexCount ? vertex_count : maxVertexCount;

                if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
                {
                    maxIdxUVCount = index_uv_count > maxIdxUVCount ? index_uv_count : maxIdxUVCount;
                    maxUVCount = uv_count > maxUVCount ? uv_count : maxUVCount;
                }
            }
        }
    }
    blk->maxIdxCount = maxIdxCount;
    blk->maxVertexCount = maxVertexCount;
    blk->validBoxCount = block_counter;

    if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
    {
        blk->maxIdxUVCount = maxIdxUVCount;
        blk->maxUVCount = maxUVCount;
    }

    return maxBoxCount;
}

/* Update position */
void UpdateVertexParents(void *parents, void *unique_parents, size_t vertex_count, size_t unique_vertex_count,
                         int vertex_stride, uint32_t *grid_remap, uint32_t *simplification_remap)
{
    for (size_t i = 0; i < vertex_count; ++i)
    {
        uint32_t j = grid_remap[i];
        uint32_t k = simplification_remap[j];
        memcpy((unsigned char *)parents + i * vertex_stride, (unsigned char *)unique_parents + k * vertex_stride, vertex_stride);
    }
}

/* Update the texture coordinates */
void UpdateUVParents(void *uv_parents, void *unique_uv_parents, size_t uv_count, size_t unique_uv_count,
                     int uv_stride, uint32_t *grid_remap_uv, uint32_t *simlification_remap_uv)
{
    for (size_t i = 0; i < uv_count; ++i)
    {
        uint32_t j = grid_remap_uv[i];
        uint32_t k = simlification_remap_uv[j];
        memcpy((unsigned char *)uv_parents + i * uv_stride, (unsigned char *)unique_uv_parents + k * uv_stride, uv_stride);
    }
}

/* Update color */
void UpdateColorParents(void *color_parents, void *unique_color_parents, size_t color_count, size_t unique_color_count,
                        int color_stride, uint32_t *grid_remap, uint32_t *simplification_remap)
{
    for (size_t i = 0; i < color_count; ++i)
    {
        uint32_t j = grid_remap[i];
        uint32_t k = simplification_remap[j];
        memcpy((unsigned char *)color_parents + i * color_stride, (unsigned char *)unique_color_parents + k * color_stride, color_stride);
    }
}

void WritebackVertexParents(LOD *mg, int box_count, uint64_t *boxes, Mesh &data)
{
    size_t vertex_offset = 0;

    for (int i = 0; i < box_count; ++i)
    {
        uint64_t box = boxes[i];

        int vertex_parent_count = mg->cubeTable[box].GetVertexParentCount();
        int index_count = mg->cubeTable[box].GetIndexParentCount();
        
        /* position, indices, normals */
        const void *vertex_src = (unsigned char *)&data.positions[0] + vertex_offset * VERTEX_STRIDE;
        const void *normal_src = (unsigned char *)&data.normals[0] + vertex_offset * VERTEX_STRIDE;
        uint32_t *grid_remap = (uint32_t *)malloc(vertex_parent_count * sizeof(uint32_t));
        uint32_t *indices = (uint32_t *)malloc(index_count * sizeof(uint32_t));
        void *unique_vertex_src = malloc(vertex_parent_count * VERTEX_STRIDE);
        void *unique_normal_src = malloc(vertex_parent_count * VERTEX_STRIDE);

        /* uvs */
        void *unique_uv_src = nullptr;
        const void *uv_src = nullptr;

        /* colors */
        const void *color_src = nullptr;
        void *unique_color_src = nullptr;

        /*assignment*/
        size_t unique_vertex_count = 0;
        mempcpy(indices, &mg->cubeTable[box].parentMesh.indices[0], index_count * sizeof(uint32_t));
        
        if(modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture){
            uv_src = (unsigned char *)&data.uvs[0] + vertex_offset * UV_STRIDE;
            unique_uv_src = malloc(vertex_parent_count * UV_STRIDE);
            unique_vertex_count = meshopt_generateVertexRemapwithUV(grid_remap, NULL, vertex_parent_count,
                                                                       vertex_src, vertex_parent_count, uv_src, 5 * sizeof(float));
            meshopt_remapVertexBufferwithUV(unique_vertex_src, vertex_src, unique_uv_src, uv_src, vertex_parent_count, VERTEX_STRIDE, grid_remap);

            mg->cubeTable[box].parentMesh.uvs = (float *)malloc(unique_vertex_count * UV_STRIDE);
            memcpy(&mg->cubeTable[box].parentMesh.uvs[0], unique_uv_src, unique_vertex_count * UV_STRIDE);

            MemoryFree(unique_uv_src);

            /* update uv number */
            mg->cubeTable[box].parentMesh.uvCount = unique_vertex_count;
            mg->cubeTable[box].parentMesh.idxUVCount = index_count;
        }
        else if(modelAttriSatus.hasColor){
            color_src = (unsigned char *)&data.colors[0] + vertex_offset * COLOR_STRIDE;
            unique_color_src = malloc(vertex_parent_count * COLOR_STRIDE);

            unique_vertex_count = meshopt_generateVertexRemap(grid_remap, NULL, vertex_parent_count, vertex_src, vertex_parent_count, VERTEX_STRIDE);
            meshopt_remapVertexBuffer(unique_vertex_src, vertex_src, vertex_parent_count, VERTEX_STRIDE, grid_remap);
            meshopt_remapVertexBuffer(unique_color_src, color_src, vertex_parent_count, COLOR_STRIDE, grid_remap);

            mg->cubeTable[box].parentMesh.colors = (u_char *)malloc(unique_vertex_count * COLOR_STRIDE);
            memcpy(&mg->cubeTable[box].parentMesh.colors[0], unique_color_src, unique_vertex_count * COLOR_STRIDE);

            MemoryFree(unique_color_src);
        }
        else{
            unique_vertex_count = meshopt_generateVertexRemap(grid_remap, NULL, vertex_parent_count, vertex_src, vertex_parent_count, VERTEX_STRIDE);
            meshopt_remapVertexBuffer(unique_vertex_src, vertex_src, vertex_parent_count, VERTEX_STRIDE, grid_remap);
        }

        /*normals*/
        meshopt_remapVertexBuffer(unique_normal_src, normal_src, vertex_parent_count, VERTEX_STRIDE, grid_remap);

        for (int i = 0; i < index_count; i += 3)
        {
            indices[i] = grid_remap[indices[i]];
            indices[i + 1] = grid_remap[indices[i + 1]];
            indices[i + 2] = grid_remap[indices[i + 2]];
        }

        /* copy parentMesh vertices, normals, indices */
        mg->cubeTable[box].parentMesh.positions = (float *)malloc(unique_vertex_count * 3 * sizeof(float));
        memcpy(&mg->cubeTable[box].parentMesh.positions[0], unique_vertex_src, unique_vertex_count * VERTEX_STRIDE);

        mg->cubeTable[box].parentMesh.normals = (float *)malloc(unique_vertex_count * 3 * sizeof(float));
        memcpy(&mg->cubeTable[box].parentMesh.normals[0], unique_normal_src, unique_vertex_count * VERTEX_STRIDE);

        mg->cubeTable[box].parentMesh.indices = (uint32_t *)malloc(index_count * sizeof(uint32_t));
        memcpy(&mg->cubeTable[box].parentMesh.indices[0], indices, index_count * sizeof(uint32_t));

        /* write back remap information */
        assert(vertex_parent_count == mg->cubeTable[box].GetVertexCount());
        mg->cubeTable[box].mesh.remap = (uint32_t *)malloc(sizeof(uint32_t) * mg->cubeTable[box].GetVertexCount());
        for (int i = 0; i < mg->cubeTable[box].GetVertexCount(); ++i)
        {
            mg->cubeTable[box].mesh.remap[i] = grid_remap[i];
        }

        /* Update the number of parent */
        mg->cubeTable[box].parentMesh.posCount = unique_vertex_count;
        mg->cubeTable[box].parentMesh.idxCount = index_count;

        /* Free the space */
        MemoryFree(grid_remap);
        MemoryFree(indices);
        MemoryFree(unique_vertex_src);
        MemoryFree(unique_normal_src);

        vertex_offset += vertex_parent_count;
    }
}


void InitParentMeshGrid(LOD *pmg, LOD *mg)
{
    pmg->level = mg->level - 1;
    pmg->gridSize = mg->gridSize / 2 ;

    pmg->max[0] = mg->max[0];
    pmg->max[1] = mg->max[1];
    pmg->max[2] = mg->max[2];

    pmg->min[0] = mg->min[0];
    pmg->min[1] = mg->min[1];
    pmg->min[2] = mg->min[2];

    pmg->step = mg->step * 0.5f;
    pmg->cubeLength = mg->cubeLength * 2.0f;
}

void *BlockSimplification(Parameter data, unsigned block_idx)
{
    Parameter tmp = data;

    Boxcoord bottom;
    bottom = tmp.simplifyBlks.list[block_idx];

    uint64_t *box = (uint64_t *)malloc(tmp.simplifyBlks.maxBoxCount * sizeof(uint64_t));
    void *unique_positions = malloc(tmp.simplifyBlks.maxVertexCount * 3 * sizeof(float));
    uint32_t *grid_remap = (uint32_t *)malloc(tmp.simplifyBlks.maxVertexCount * sizeof(uint32_t));
    uint32_t *simplification_remap = (uint32_t *)malloc(tmp.simplifyBlks.maxVertexCount * sizeof(uint32_t));
    void *unique_uvs;
    uint32_t *simplification_remap_uv;

    /* Mesh data buffer */
    Mesh blk_data;
    blk_data.indices = (uint32_t *)malloc(tmp.simplifyBlks.maxIdxCount * sizeof(uint32_t));
    blk_data.positions = (float *)malloc(tmp.simplifyBlks.maxVertexCount * 3 * sizeof(float));
    blk_data.normals = (float *)malloc(tmp.simplifyBlks.maxVertexCount * 3 * sizeof(float));
    blk_data.idxCount = 0;
    blk_data.posCount = 0;

    /*if the texture coordinates exist*/
    if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
    {
        blk_data.indicesUV = (uint32_t *)malloc(tmp.simplifyBlks.maxIdxUVCount * sizeof(uint32_t));
        blk_data.uvs = (float *)malloc(tmp.simplifyBlks.maxUVCount * 2 * sizeof(float));
        blk_data.idxUVCount = 0;
        blk_data.uvCount = 0;

        unique_uvs = malloc(tmp.simplifyBlks.maxUVCount * 2 * sizeof(float));
        simplification_remap_uv = (uint32_t *)malloc(tmp.simplifyBlks.maxUVCount * sizeof(uint32_t));
    }
    
    unsigned box_count = LoadBlockData(tmp.mg, bottom, tmp.simplifyBlks.width, box, &blk_data, true, true);
    
    if (!box_count)
        return NULL;

    size_t unique_vertex_count = 0;
    size_t out_index_count = 0;

    float extension = tmp.mg->cubeLength;
    float simplification_error = tmp.targetError * extension;
    float block_extension = 4 * extension;

    Boxcoord coord_real;
    coord_real.x = (bottom.x - tmp.simplifyBlks.width / 2);
    coord_real.y = (bottom.y - tmp.simplifyBlks.width / 2);
    coord_real.z = (bottom.z - tmp.simplifyBlks.width / 2);
    float block_bottom[3];
    block_bottom[0] = tmp.mg->min[0] + coord_real.x * extension;
    block_bottom[1] = tmp.mg->min[1] + coord_real.y * extension;
    block_bottom[2] = tmp.mg->min[2] + coord_real.z * extension;

    if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
    {
        unique_vertex_count = meshopt_generateVertexRemapwithUV(grid_remap, NULL, blk_data.posCount, blk_data.positions, blk_data.posCount, blk_data.uvs, 5 * sizeof(float));
        meshopt_remapVertexBufferwithUV(unique_positions, blk_data.positions, unique_uvs, blk_data.uvs, blk_data.posCount, 3 * sizeof(float), grid_remap);
        RemapIndexBufferSkipDegenerate(blk_data.indicesUV, blk_data.idxCount, grid_remap);
        blk_data.idxCount = RemapIndexBufferSkipDegenerate(blk_data.indices, blk_data.idxCount, grid_remap);

        out_index_count = CollapseSimplifyMeshTex(blk_data.indices, blk_data.indicesUV, simplification_remap, simplification_remap_uv,
                                                  blk_data.indices, blk_data.idxCount, blk_data.indicesUV, blk_data.idxCount, unique_positions, unique_vertex_count, unique_uvs, unique_vertex_count,
                                                  3 * sizeof(float), 2 * sizeof(float), blk_data.idxCount / 4, simplification_error, block_extension, block_bottom);
        
        UpdateVertexParents(blk_data.positions, unique_positions, blk_data.posCount, unique_vertex_count, 3 * sizeof(float), grid_remap, simplification_remap);
        UpdateUVParents(blk_data.uvs, unique_uvs, blk_data.posCount, unique_vertex_count, 2 * sizeof(float), grid_remap, simplification_remap_uv);
        //WritebackVertexParentsUV(tmp.mg, box_count, box, blk_data.positions, blk_data.uvs);
        WritebackVertexParents(tmp.mg, box_count, box, blk_data);
    }
    else
    {
        unique_vertex_count = meshopt_generateVertexRemap(grid_remap, NULL, blk_data.posCount, blk_data.positions, blk_data.posCount, 3 * sizeof(float));
        meshopt_remapVertexBuffer(unique_positions, blk_data.positions, blk_data.posCount, 3 * sizeof(float), grid_remap);
        blk_data.idxCount = RemapIndexBufferSkipDegenerate(blk_data.indices, blk_data.idxCount, grid_remap);

        out_index_count = CollapseSimplifyMesh(blk_data.indices, simplification_remap, blk_data.indices, blk_data.idxCount, unique_positions,
                                               unique_vertex_count, 3 * sizeof(float), blk_data.idxCount / 4, simplification_error, block_extension, block_bottom);

        /* Update and wirte back parent information */
        UpdateVertexParents(blk_data.positions, unique_positions, blk_data.posCount, unique_vertex_count, 3 * sizeof(float), grid_remap, simplification_remap);
        WritebackVertexParents(tmp.mg, box_count, box, blk_data);
    }

    uint64_t *boxes_2 = (uint64_t *)malloc(tmp.parentBlks.maxBoxCount * sizeof(uint64_t));
    void *unique_positions_2 = malloc(tmp.parentBlks.maxVertexCount * 3 * sizeof(float));
    void *unique_normals_2 = malloc(tmp.parentBlks.maxVertexCount * 3 * sizeof(float));
    uint32_t *remap_2 = (uint32_t *)malloc(tmp.parentBlks.maxVertexCount * sizeof(uint32_t));
    void *unique_uvs_2;

    Mesh blk_data_2;
    blk_data_2.indices = (uint32_t *)malloc(tmp.parentBlks.maxIdxCount * sizeof(uint32_t));
    blk_data_2.positions = (float *)malloc(tmp.parentBlks.maxVertexCount * 3 * sizeof(float));
    blk_data_2.normals = (float *)malloc(tmp.parentBlks.maxVertexCount * 3 * sizeof(float));
    if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
    {
        blk_data_2.indicesUV = (uint32_t *)malloc(tmp.parentBlks.maxIdxCount * sizeof(uint32_t));
        blk_data_2.uvs = (float *)malloc(tmp.parentBlks.maxVertexCount * 2 * sizeof(float));
        unique_uvs_2 = malloc(tmp.parentBlks.maxVertexCount * 2 * sizeof(float));
    }
    
    for (unsigned short ix = bottom.x; ix < bottom.x + tmp.simplifyBlks.width; ix = ix + 2)
    {
        for (unsigned short iy = bottom.y; iy < bottom.y + tmp.simplifyBlks.width; iy = iy + 2)
        {
            for (unsigned short iz = bottom.z; iz < bottom.z + tmp.simplifyBlks.width; iz = iz + 2)
            {

                Boxcoord bottom_2;
                bottom_2.x = ix, bottom_2.y = iy, bottom_2.z = iz;

                blk_data_2.idxCount = 0;
                blk_data_2.posCount = 0;
                blk_data_2.uvCount = 0;
                blk_data_2.idxUVCount = 0;

                unsigned child_cell_count = LoadBlockData(tmp.mg, bottom_2, 2, boxes_2, &blk_data_2, true, true);

                if (!child_cell_count)
                    continue;

                size_t unique_vertex_count_2 = 0;

                if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
                {
                    unique_vertex_count_2 = meshopt_generateVertexRemapwithUV(remap_2, blk_data_2.indices, blk_data_2.idxCount, blk_data_2.positions, blk_data_2.posCount, blk_data_2.uvs, 5 * sizeof(float));
                    meshopt_remapVertexBufferwithUV(unique_positions_2, blk_data_2.positions, unique_uvs_2, blk_data_2.uvs, blk_data_2.posCount, 3 * sizeof(float), remap_2);
                    blk_data_2.idxCount = RemapIndexBufferSkipDegenerate(blk_data_2.indices, blk_data_2.idxCount, remap_2);
                }
                else
                {
                    unique_vertex_count_2 = meshopt_generateVertexRemap(remap_2, blk_data_2.indices, blk_data_2.idxCount, blk_data_2.positions, blk_data_2.posCount, 3 * sizeof(float));
                    meshopt_remapVertexBuffer(unique_positions_2, blk_data_2.positions, blk_data_2.posCount, 3 * sizeof(float), remap_2);
                    meshopt_remapVertexBuffer(unique_normals_2, blk_data_2.normals, blk_data_2.posCount, 3 * sizeof(float), remap_2);
                    blk_data_2.idxCount = RemapIndexBufferSkipDegenerate(blk_data_2.indices, blk_data_2.idxCount, remap_2);
                }

                bottom_2.x = short((bottom_2.x - tmp.simplifyBlks.width / 2) / 2);
                bottom_2.y = short((bottom_2.y - tmp.simplifyBlks.width / 2) / 2);
                bottom_2.z = short((bottom_2.z - tmp.simplifyBlks.width / 2) / 2);

                uint64_t ijk_p = (uint64_t)(bottom_2.x) | ((uint64_t)(bottom_2.y) << 16) | ((uint64_t)(bottom_2.z) << 32);

                Cube cell_p;

                cell_p.ijk[0] = bottom_2.x;
                cell_p.ijk[1] = bottom_2.y;
                cell_p.ijk[2] = bottom_2.z;

                /*update the number of vertex and index*/
                cell_p.mesh.idxCount = blk_data_2.idxCount;
                cell_p.mesh.posCount = unique_vertex_count_2;

                cell_p.mesh.positions = (float *)malloc(unique_vertex_count_2 * 3 * sizeof(float));
                cell_p.mesh.normals = (float *)malloc(unique_vertex_count_2 * 3 * sizeof(float));
                cell_p.mesh.indices = (uint32_t *)malloc(blk_data_2.idxCount * sizeof(uint32_t));

                memcpy(cell_p.mesh.indices, blk_data_2.indices, blk_data_2.idxCount * sizeof(uint32_t));
                memcpy(cell_p.mesh.positions, unique_positions_2, unique_vertex_count_2 * sizeof(float) * 3);
                memcpy(cell_p.mesh.normals, unique_normals_2, unique_vertex_count_2 * sizeof(float) * 3);

                /* texture coordinates exist */
                if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
                {
                    cell_p.mesh.idxUVCount = blk_data_2.idxCount;
                    cell_p.mesh.uvCount = unique_vertex_count_2;
                    cell_p.mesh.uvs = (float *)malloc(unique_vertex_count_2 * 2 * sizeof(float));
                    memcpy(cell_p.mesh.uvs, unique_uvs_2, unique_vertex_count_2 * sizeof(float) * 2);
                }

                tmp.pmg->cubeTable.insert(pair<uint64_t, Cube>(ijk_p, cell_p));

                /* Upadate the vertex parent remap */
                size_t vertex_offset = 0;
                for (int i = 0; i < child_cell_count; ++i)
                {
                    uint64_t ijk_child = boxes_2[i];
                    for (int j = 0; j < tmp.mg->cubeTable[ijk_child].GetVertexCount(); ++j)
                    {
                        uint32_t k = tmp.mg->cubeTable[ijk_child].mesh.remap[j];
                        uint32_t l = k + vertex_offset;
                        tmp.mg->cubeTable[ijk_child].mesh.remap[j] = remap_2[l];
                    }
                    vertex_offset += tmp.mg->cubeTable[ijk_child].GetVertexParentCount();
                }
            }
        }
    }


    /* Free memory space */
    /* simplification block data */
    MemoryFree(box);
    MemoryFree(unique_positions);
    MemoryFree(grid_remap);
    MemoryFree(simplification_remap);
        
    /* parent reconstruction block data */
    MemoryFree(boxes_2);
    MemoryFree(unique_positions_2);
    MemoryFree(unique_normals_2);
    MemoryFree(remap_2);

    if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture){
        MemoryFree(unique_uvs);
        MemoryFree(simplification_remap_uv);
        MemoryFree(unique_uvs_2);
    }
    
    return NULL;
}


bool BuileNextBlock(Parameter param)
{
    pthread_mutex_lock(&block_index_mutex);
    unsigned cur = idx_to_do;
    if (cur >= param.simplifyBlks.validBoxCount)
    {
        pthread_mutex_unlock(&block_index_mutex);
        return false;
    }
    idx_to_do++;

    pthread_mutex_unlock(&block_index_mutex);

    BlockSimplification(param, cur);

    return true;
}

void *BuildParallel(void *arg)
{
    Parameter tmp = *(Parameter *)arg;

    while (BuileNextBlock(tmp))
    {
    }
    return NULL;
}

void LODConstructor(LOD *mg, LOD *pmg, int width, float targetError, int max_level)
{
    int grid_size = mg->gridSize;
    int vertex_stride = VERTEX_STRIDE;
    unsigned uv_stride = UV_STRIDE;

    /*simplification block information*/
    unsigned short value = int((grid_size + width) / width);
    unsigned short block_max_num = 0;
    block_max_num = value * value * value;

    Block blks_simplify;
    blks_simplify.width = width;
    blks_simplify.list = (Boxcoord *)calloc(block_max_num, block_max_num * 3 * sizeof(unsigned short));
    blks_simplify.maxBoxCount = ComputeMaxCounts(mg, &blks_simplify);

    /*parent cube construction block information*/
    Block blks_parent;
    blks_parent.width = 2;
    blks_parent.list = (Boxcoord *)calloc(block_max_num / 8, (block_max_num / 8) * 3 * sizeof(unsigned short));
    blks_parent.maxBoxCount = ComputeMaxCounts(mg, &blks_parent);

    /*thread parameter*/
    Parameter attr;
    attr.mg = mg;
    attr.pmg = pmg;
    attr.simplifyBlks = blks_simplify;
    attr.parentBlks = blks_parent;
    attr.targetError = targetError;
    idx_to_do = 0;

    /* create threads */
    pthread_t threads[threadNum];
    pthread_mutex_init(&block_index_mutex, NULL);

    for (int i = 0; i < threadNum; ++i)
    {
        pthread_create(&threads[i], NULL, BuildParallel, (void *)&attr);
    }
    for (int i = 0; i < threadNum; ++i)
    {

        pthread_join(threads[i], NULL);
    }
    pthread_mutex_destroy(&block_index_mutex);

    /* Fill the parent data for the new generated LOD */
    for (auto &cb : pmg->cubeTable)
    {
        /*update the number of parent*/
        cb.second.parentMesh.posCount = cb.second.mesh.posCount;
        cb.second.parentMesh.idxCount = cb.second.mesh.idxCount;

        cb.second.parentMesh.positions = (float *)malloc(sizeof(float) * 3 * cb.second.parentMesh.posCount);
        cb.second.parentMesh.normals = (float *)malloc(sizeof(float) * 3 * cb.second.parentMesh.posCount);
        cb.second.parentMesh.indices = (uint32_t *)malloc(sizeof(uint32_t) * cb.second.parentMesh.idxCount);

        memcpy(cb.second.parentMesh.positions, cb.second.mesh.positions, cb.second.parentMesh.posCount * 3 * sizeof(float));
        memcpy(cb.second.parentMesh.normals, cb.second.mesh.normals, cb.second.parentMesh.posCount * 3 * sizeof(float));
        memcpy(cb.second.parentMesh.indices, cb.second.mesh.indices, cb.second.parentMesh.idxCount * sizeof(uint32_t));

        if (modelAttriSatus.hasSingleTexture || modelAttriSatus.hasMultiTexture)
        {
            cb.second.parentMesh.uvCount = cb.second.mesh.uvCount;
            cb.second.parentMesh.idxUVCount = cb.second.mesh.idxUVCount;
            cb.second.parentMesh.uvs = (float *)malloc(sizeof(float) * 2 * cb.second.parentMesh.uvCount);
            memcpy(cb.second.parentMesh.uvs, cb.second.mesh.uvs, cb.second.parentMesh.uvCount * 2 * sizeof(float));
        }

        /*if it is the coarst level, remap is itself*/
        if (pmg->level == 0)
        {
            cb.second.mesh.remap = (uint32_t *)malloc(cb.second.mesh.posCount * sizeof(uint32_t));
            for (int i = 0; i < cb.second.mesh.posCount; ++i)
                cb.second.mesh.remap[i] = i;
        }

        /*compute physical bottom point of cube*/
        cb.second.ComputeBottomVertex(cb.second.bottom, cb.second.ijk, pmg->cubeLength, pmg->min);
    }

    /* free the parent mesh of higher resolution LOD */
    for (auto &cb : mg->cubeTable)
    {
        mg->CleanBBXData(cb.second);
    }

    /* free data */
    MemoryFree(blks_simplify.list);
}

void LODConstructor(HLOD *hlod, int curLevel, int width, float targetError, int max_level){
    /* Init parent mesh level */
    InitParentMeshGrid(hlod->lods[curLevel+1], hlod->lods[curLevel]);
    
    int grid_size = hlod->lods[curLevel]->gridSize;
    int vertex_stride = VERTEX_STRIDE;
    unsigned uv_stride = UV_STRIDE;

    /*simplification block information*/
    unsigned short value = int((grid_size + width) / width);
    unsigned short block_max_num = 0;
    block_max_num = value * value * value;

    Block blks_simplify;
    blks_simplify.width = width;
    blks_simplify.list = (Boxcoord *)calloc(block_max_num, block_max_num * 3 * sizeof(unsigned short));
    blks_simplify.maxBoxCount = ComputeMaxCounts(hlod, curLevel, &blks_simplify);

    /*parent cube construction block information*/
    Block blks_parent;
    blks_parent.width = 2;
    blks_parent.list = (Boxcoord *)calloc(block_max_num / 8, (block_max_num / 8) * 3 * sizeof(unsigned short));
    blks_parent.maxBoxCount = ComputeMaxCounts(hlod, curLevel, &blks_parent);
    
    /*thread parameter*/
    Parameter attr;
    attr.hlod = hlod;
    attr.curLevel = curLevel;
    attr.mg = hlod->lods[curLevel];
    attr.pmg = hlod->lods[curLevel + 1];
    attr.simplifyBlks = blks_simplify;
    attr.parentBlks = blks_parent;
    attr.targetError = targetError;
    idx_to_do = 0;

    /* create threads */
    pthread_t threads[threadNum];
    pthread_mutex_init(&block_index_mutex, NULL);

    for (int i = 0; i < threadNum; ++i)
    {
        pthread_create(&threads[i], NULL, BuildParallel, (void *)&attr);
    }
    for (int i = 0; i < threadNum; ++i)
    {

        pthread_join(threads[i], NULL);
    }
    pthread_mutex_destroy(&block_index_mutex);

    /* Fill the parent data for the new generated LOD */
    for (auto &cb : hlod->lods[curLevel + 1]->cubeTable)
    {
        /*if it is the coarst level, remap is itself*/
        if (hlod->lods[curLevel + 1]->level == 0)
        {
            cb.second.mesh.remap = (uint32_t *)malloc(cb.second.mesh.posCount * sizeof(uint32_t));
            for (int i = 0; i < cb.second.mesh.posCount; ++i)
                cb.second.mesh.remap[i] = i;
        }

        /*compute physical bottom point of cube*/
        cb.second.ComputeBottomVertex(cb.second.bottom, cb.second.ijk, hlod->lods[curLevel + 1]->cubeLength, hlod->lods[curLevel + 1]->min);
    }

    /* free data */
    MemoryFree(blks_simplify.list);
}

void HLODConsructor(HLOD *hlod, int maxLevel, float targetError){
    /* Multi-resolution model construction */
    for (int i = 0; i < maxLevel; i++)                                          
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
        hlod->lods[i+1] = new LOD(maxLevel - 1 - i);
        cout << "LOD: " << maxLevel - 1 - i << " ";
        TimerStart();
        LODConstructor(hlod, i, SC_BLOCK_SIZE, targetError, maxLevel);
        TimerStop("build time: ");
    
        cout << "Cell: " << hlod->lods[i+1]->cubeTable.size() 
        << " faces: " << hlod->lods[i+1]->CalculateTriangleCounts() 
        << " positions:  "<< hlod->lods[i+1]->CalculateVertexCounts() 
        << " simplify ratio: " << float(hlod->lods[i+1]->totalTriCount) / float(hlod->lods[i]->totalTriCount) << endl;
    }
}